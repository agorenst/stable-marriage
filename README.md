# stable-marriage
A classic algorithm.

# Motivation
When I studied algorithms in school, I was perenially frustrated by how I couldn't "see" the algorithm in action. Ultimately, this is what I wanted:
- At the most superficial level, I wanted to have an implementation--and some inputs--just to see that the algorithm works.
(I think exploring the "distance" between the algorithmic psuedo-code, and actual code, is also quite interesting. So even if I couldn't run the code I would have liked that.)
- At a deeper level, I wanted to see what the algorithm-in-action looked like.
I don't mean simple trace statements.
Rather, if algorithms concern the manipulation of mathematical objects, I wanted to see the interplay between those objects and the algorithm.
And as an implementation of that algorithm is a mapping of the mathematical description of the algorithm, and instructions to a physical machine, well, I wanted to see what the machine actually did with that algorithm as well.
- Lastly, the idea of a library of actually-implemented algorithms as a toolbox always appealed to me.
Sure, there are real libraries with real implementations out there, but building my own toolbox had a sort of primal motivation for me.
Plus, I think it would have felt reassuring that, if a related problem piqued my interest, I had an implemented (and correct!) algorithm ready to go.
 
Now that I find myself with some spare time, I hope to slowly start providing implementation and tools that my past self (and hopefully future, similar students!) would have appreciated.

## Stable Marriage
So this repository is the collection of small programs designed to explore the "stable marriage" problem.

# Contents:
File list is still evolving. But it's all a small collection of files. I'm debating how best to present the material. First I need to know all the material.

# Todo
1. Can we create "interesting" problems? I'm thinking like ones that take the largest number of comparisons
2. Can we canonicalize the input? How many different stable marriage problems exist for N men and women?
3. Can we see how local the operations are in memory, on average?
4. Is there anything we can parallelize (for fun?)
